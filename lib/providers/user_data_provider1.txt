// ignore_for_file: use_build_context_synchronously

import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:lines_top_mobile/helpers/db_helper.dart';
import 'package:lines_top_mobile/helpers/network_connectivity.dart';

class UserDataProvider with ChangeNotifier{
  bool isAuth = false;
  String? userName;
  String? userId;
  String? email;
  bool? paidAccount;
  Map<String,List<int>>? progress;
  List<String>? savedBlogPostIds;
  List<String>? statsDates;
  Map<String,List<num>>? statisticts;
  final Stream<User?> _authStateStream = FirebaseAuth.instance.authStateChanges();


  Future<void> setListener()async{
        bool connected = await NetworkConnectivity.checkConnection();
    _authStateStream.listen((event) {
      if(event == null){
        userName = null;
        userId = null;
        email = null;
        paidAccount = null;
        progress = null;
        savedBlogPostIds = null;
        statisticts = null;
        statsDates = null;
        return;
      }
      if(event.uid != ''){

        loadData(event.uid,connected);
      }
    });
    var lastSnapshot = await _authStateStream.last;
    if (lastSnapshot != null){
      await loadData(lastSnapshot.uid,connected);
    }
  }





  Future<bool> loadData(String uid,bool internetConnected)async {
    if(!internetConnected){
      isAuth = false;
      notifyListeners();
      return true;
    }
    var userData = await DBHelper.getData('user_data');
    if (userData.indexWhere((element) => element['id'] == uid) != -1) {
      var userMap = userData.singleWhere((element) => element['id'] == uid);
      userId = userMap['id'];
      userName = userMap['username'];
      email = userMap['email'];
      paidAccount = (userMap['paid_account'] == 1);
      var savedDynamic = jsonDecode(userMap['saved_posts']) as List<dynamic>;
      savedBlogPostIds = [];
      for (String el in savedDynamic) {
        savedBlogPostIds!.add(el);
      }
      statsDates = [];
      var datesDynamic = jsonDecode(userMap['stats_dates']) as List<dynamic>;
      for (String el in datesDynamic){
        statsDates!.add(el);
      }
    Map<String,List<num>> tempStats = {};
    var statsDynamic = jsonDecode(userMap['statistics']) as Map<String,dynamic>;
    for(String statName in statsDynamic.keys){
      List<num> temp = [];
      for(int i = 0;i< statsDynamic[statName].length;i++){
        temp.add(statsDynamic[statName][i]);
      }
      tempStats.addAll({statName: temp});
    }
    statisticts = tempStats;
      Map<String, List<int>> tempProgress = {};
      var progressDynamic =
          jsonDecode(userMap['progress']) as Map<String, dynamic>;
      for (String prName in progressDynamic.keys) {
        List<int> temp = [];
        for (int i = 0; i < progressDynamic[prName].length; i++) {
          temp.add(progressDynamic[prName][i]);
        }
        tempProgress.addAll({prName: temp});
      }
      progress = tempProgress;
    }
    var docRef = FirebaseFirestore.instance.doc('users/$uid');
    var doc = await docRef.get();
    if(!doc.exists){
      return false;
    }
    userId = doc.id;
    userName = doc['user_name'];
    email = doc['email'];
    paidAccount = doc['paid_account'];
      statsDates = [];
      var datesDynamic = doc['stats_dates'] as List<dynamic>;
      for (String el in datesDynamic){
        statsDates!.add(el);
      }
    var savedDynamic = doc['saved_posts'] as List<dynamic>;
    savedBlogPostIds = [];
    for (String el in savedDynamic) {
      savedBlogPostIds!.add(el);
    }
    Map<String,List<num>> tempStats = {};
    var statsDynamic = doc['statistics'] as Map<String,dynamic>;
    for(String statName in statsDynamic.keys){
      List<num> temp = [];
      for(int i = 0;i< statsDynamic[statName].length;i++){
        temp.add(statsDynamic[statName][i]);
      }
      tempStats.addAll({statName: temp});
    }
    statisticts = tempStats;
    Map<String, List<int>> tempProgress = {};
    var progressDynamic = doc['progress'] as Map<String, dynamic>;
    for (String prName in progressDynamic.keys) {
      List<int> temp = [];
      for (int i = 0; i < progressDynamic[prName].length; i++) {
        temp.add(progressDynamic[prName][i]);
      }
      tempProgress.addAll({prName: temp});
    }
    progress = tempProgress;
    isAuth = true;
    notifyListeners();
    await DBHelper.insert('user_data', {
      'id': userId!,
      'username': userName!,
      'email': email!,
      'paid_account': 0,
      'progress': jsonEncode(progress),
      'stats_dates': jsonEncode(statsDates),
      'saved_posts': jsonEncode(savedBlogPostIds),
      'statistics': jsonEncode(statisticts),
    });
    return true;
  }

  Future<bool> addSavedId(String newId)async {
    List<String> temp = [...savedBlogPostIds!];
    temp.add(newId);
    var userData = FirebaseFirestore.instance.doc('users/$userId');
    try {
      await userData.update({'saved_posts': temp});
      savedBlogPostIds!.add(newId);
      notifyListeners();
      return true;
    } catch(e){
      print(e);
      notifyListeners();
      return false;
    }
  }
  Future<bool> removeSavedId(String newId)async {
    List<String> temp = [...savedBlogPostIds!];
    temp.remove(newId);
    var userData = FirebaseFirestore.instance.doc('users/$userId');
    try {
      await userData.update({'saved_posts': temp});
      savedBlogPostIds!.remove(newId);
      notifyListeners();
      return true;
    } catch(e){
      print(e);
      notifyListeners();
      return false;
    }
  }

  Future<bool> changeEmail(String newEmail)async {
    try{
      AuthCredential authCredential = EmailAuthProvider.credential(
        email: email!,
        password: '123321',
      );
      await FirebaseAuth.instance.currentUser!.reauthenticateWithCredential(authCredential);
      await FirebaseAuth.instance.currentUser!.updateEmail(newEmail);
      email = newEmail;
      notifyListeners();
      return true;
    }on FirebaseAuthException catch(e){
      print(e);
      return false;
    }
  }

  Future<bool> changePassword(String oldPassword,String newPassword)async {
    try{
      AuthCredential authCredential = EmailAuthProvider.credential(
        email: email!,
        password: oldPassword,
      );
      await FirebaseAuth.instance.currentUser!.reauthenticateWithCredential(authCredential);
      print('reauth');
      await FirebaseAuth.instance.currentUser!.updatePassword(newPassword);
      return true;
    }on FirebaseAuthException catch(e){
      print(e);
      return false;
    }
  }

  Future<bool> updateStatistics(Map<String,List<num>> newStats)async{
    try {
      var now = DateTime.now();
      if (statsDates!.isEmpty) {
        statsDates!.add('${now.day}.${now.month}.${now.year}');
        statisticts = newStats;
      } else {
        if (statsDates!.last == '${now.day}.${now.month}.${now.year}') {
          for (var key in statisticts!.keys) {
            if (newStats.containsKey(key)) {
              statisticts![key]!.last = newStats[key]!.last;
            }
          }
        } else {
        statsDates!.add('${now.day}.${now.month}.${now.year}');
          for (var key in statisticts!.keys) {
            if (newStats.containsKey(key)) {
              statisticts![key]!.addAll(newStats[key]!);
            } else {
              statisticts![key]!.add(statisticts![key]!.last);
            }
          }
        }
      }



    await DBHelper.insert('user_data', {
      'id': userId!,
      'username': userName!,
      'email': email!,
      'paid_account': paidAccount! ? 1: 0,
      'progress': jsonEncode(progress),
      'statistics': jsonEncode(statisticts),
      'stats_dates': jsonEncode(statsDates),
      'saved_posts': jsonEncode(savedBlogPostIds),
    });
    var userData = FirebaseFirestore.instance.doc('users/$userId');
    await userData.update({'statistics': statisticts,
    'stats_dates': statsDates});
    notifyListeners();
    } catch (e){
      return false;
    }
    return true;
  }

  Future<bool> updateProgress(Map<String,List<int>> newProgress,{required BuildContext context}) async {
    progress = newProgress;
    await DBHelper.insert('user_data', {
      'id': userId!,
      'username': userName!,
      'email': email!,
      'paid_account': paidAccount! ? 1: 0,
      'progress': jsonEncode(progress),
      'stats_dates': jsonEncode(statsDates),
      'statistics': jsonEncode(statisticts),
      'saved_posts': jsonEncode(savedBlogPostIds),
    });
    var userData = FirebaseFirestore.instance.doc('users/$userId');
    try {
      await userData.update({'progress' : newProgress});
    
    } catch (e) {
        ScaffoldMessenger.of(context).clearSnackBars();
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.toString())));
        return false;
    }
    notifyListeners();
    return true;
  }

  Future<bool> registerUser(String userName,String email,String password,{required BuildContext context}) async {
      try {
      var userCredentials = await FirebaseAuth.instance.createUserWithEmailAndPassword(email: email, password: password);
      this.userName = userName.trim();
      this.email = email.trim();
      userId = userCredentials.user!.uid;
      paidAccount = false;
      var programs = await FirebaseFirestore.instance.collection('programs').get();
      var programsNames = programs.docs.map((e) => e.id).toList();
      progress = {};
      for(int i = 0;i<programsNames.length;i++){
        Map<String,List<int>> temp = {programsNames[i]:List.generate(programs.docs[i].data()['trainings'].length, (index) => 0)};
        progress!.addAll(temp);
      }
      var usersCollection = FirebaseFirestore.instance.collection('users');
      await usersCollection.doc(userCredentials.user!.uid).set({
        'email' : this.email,
        'user_name': this.userName,
        'paid_account': false,
        'progress': progress,
        'stats_dates': [],
        'saved_posts': [],
        'statistics': {},
      });
      isAuth = true;
      savedBlogPostIds = [];
      statisticts = {};
      statsDates = [];
      notifyListeners();
      await DBHelper.insert('user_data', {
        'id': userId!,
        'username': this.userName!,
        'email': this.email!,
        'paid_account': 0,
        'stats_dates': jsonEncode(statsDates),
        'progress': jsonEncode(progress),
        'saved_posts': jsonEncode(savedBlogPostIds),
        'statistics': jsonEncode({}),
      });
      return true;
      } on FirebaseAuthException catch (e) {
        ScaffoldMessenger.of(context).clearSnackBars();
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.message!)));
        return false;
      }
  }

   Future<bool> loginUser(String email,String password,{required BuildContext context}) async {
    try{
      var userCredentials = await FirebaseAuth.instance.signInWithEmailAndPassword(email: email, password: password);
      loadData(userCredentials.user!.uid,true);
      /*
      var userSnapshot = await FirebaseFirestore.instance.collection('users').doc(userCredentials.user!.uid).get();
      var userData = userSnapshot.data()!;
      userId = userCredentials.user!.uid;
      this.email = userData['email'];
      paidAccount = userData['paid_account'];
      userName = userData['user_name'];
      var savedDynamic = userData['saved_posts'] as List<dynamic>;
      savedBlogPostIds = [];
      for(String el in savedDynamic){
        savedBlogPostIds!.add(el);
      }
      Map<String,List<int>> tempProgress = {};
      var progressDynamic = userData['progress'] as Map<String,dynamic>;
      for(String prName in progressDynamic.keys){
        List<int> temp = [];
        for(int i=0;i < progressDynamic[prName].length;i++){
          temp.add(progressDynamic[prName][i]);
        }
        tempProgress.addAll({prName: temp});
      }
      progress = tempProgress;
      isAuth = true;
      notifyListeners();
      */
      return true;
    } on FirebaseAuthException catch (e){
        ScaffoldMessenger.of(context).clearSnackBars();
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.message!)));
        notifyListeners();
        return false;
    }
   }

   Future<bool> logoutUser()async{
    try{
     await FirebaseAuth.instance.signOut();
     isAuth = false;
     userId = null;
     userName = null;
     progress = null;
     email = null;
     statisticts = null;
     statsDates = null;
     notifyListeners();
     return true;

    }catch(e){
      print(e);
      return false;
    }

   }

  Future<String> changeUsername(String newUsername) async {
    newUsername = newUsername.trim();
    if(newUsername.length < 4) {
      return 'Имя пользователя слишком короткое';
    }
    if(newUsername == userName){
      return 'Нельзя изменить имя пользователя на текущее';
    }
    try {
      var userRef = FirebaseFirestore.instance.doc('users/$userId');
      await userRef.update({'user_name' : newUsername});
    } on FirebaseException catch (e){
      return e.toString();
    }
    return 'Успешно';
  }




  Future<void> changeAllVersions() async {
    var exRef = FirebaseFirestore.instance.collection('exercises');
    var blogRef = FirebaseFirestore.instance.collection('blog_posts');
    var prRef = FirebaseFirestore.instance.collection('programs');
    var trRef = FirebaseFirestore.instance.collection('trainings');
    var exercises = (await exRef.get()).docs;
    for(var ex in exercises){
      var ref = exRef.doc(ex.id);
      await ref.update({'version': ex['version']+1});
    }
    var posts = (await blogRef.get()).docs;
    for(var post in posts){
      var ref = blogRef.doc(post.id);
      await ref.update({'version': post['version']+1});
    }
    var programs = (await prRef.get()).docs;
    for(var pr in programs){
      var ref = prRef.doc(pr.id);
      await ref.update({'version': pr['version']+1});
    }
    var trainings = (await trRef.get()).docs;
    for(var tr in trainings){
      var ref = trRef.doc(tr.id);
      await ref.update({'version': tr['version']+1});
    }
  }


  Future<void> deleteStats()async{
    statisticts = {};
    statsDates = [];
    await DBHelper.insert('user_data', {
      'id': userId!,
      'username': userName!,
      'email': email!,
      'paid_account': paidAccount! ? 1: 0,
      'progress': jsonEncode(progress),
      'statistics': jsonEncode({}),
      'saved_posts': jsonEncode(savedBlogPostIds),
      'stats_dates': jsonEncode([]),
    }); 
    var userData = FirebaseFirestore.instance.doc('users/$userId');
    await userData.update({'statistics': {},
          'stats_dates': [],
});
    notifyListeners();
    return;
  }

  
  

  @override 
  String toString() {
    return isAuth ? 
    'AUTH - \n id - $userId \n name - $userName \n email - $email \n savedPosts - $savedBlogPostIds \n progress - $progress \n stats - $statisticts \n dates $statsDates'
    :
    'NOT AUTH';
  }
}